> [0. Acerca del Grupo](../../0.md) › [0.6. Temas Individuales (Parte 1)](../0.6.md) › [0.6.4. Integrante 4](0.6.4.md)

# 0.6.4. Integrante 4

# Informe Individual – Táctica: Uso de Bases de Datos NoSQL Clave-Valor  

**Nombre:** Hideki Sotero Huaroto  
**Curso:** Arquitectura de Software  
**Docente:** Jose Caballero Ortiz  
**Tema aprobado:** Bases de datos NoSQL clave-valor

---

## 1. Introducción  

En el contexto de la arquitectura de software moderna, los sistemas deben manejar grandes volúmenes de datos con alta velocidad, disponibilidad y escalabilidad.  
Las bases de datos tradicionales relacionales (SQL) pueden presentar limitaciones ante estas necesidades, especialmente cuando los datos son altamente dinámicos, no estructurados o requieren una latencia muy baja.  

Las bases de datos NoSQL surgen como una alternativa flexible que permite diferentes modelos de almacenamiento. Entre ellos, las bases de datos clave-valor destacan por su simplicidad y alto rendimiento, convirtiéndose en una pieza esencial en arquitecturas de microservicios, caching y sistemas de tiempo real.  

---

## 2. Concepto de bases de datos NoSQL clave-valor  

Una base de datos clave-valor almacena la información como pares únicos de clave y valor, donde la clave actúa como un identificador y el valor puede ser cualquier tipo de dato (texto, número, JSON u objeto binario).  

> **Ejemplo:**  
> `user:1001 → {"nombre": "Lucía", "edad": 25}`

El acceso a la información se realiza mediante operaciones simples:  
- `SET` para escribir.  
- `GET` para leer.  
- `DEL` para eliminar.  

A diferencia de las bases relacionales, este tipo de sistema no necesita un esquema fijo ni realiza consultas complejas, priorizando la **velocidad y eficiencia** sobre la estructura.

### Operaciones atómicas en bases de datos clave-valor

Las bases de datos clave-valor, como Redis, ofrecen **operaciones atómicas**, es decir, acciones que se ejecutan completamente o no se ejecutan en absoluto, evitando conflictos cuando múltiples clientes acceden a la misma clave simultáneamente.  
Estas operaciones garantizan **consistencia y seguridad** sin necesidad de mecanismos de bloqueo ni transacciones complejas.

Algunas de las operaciones atómicas más comunes son:

| **Comando** | **Descripción** | **Ejemplo** |
|--------------|----------------|--------------|
| `INCR key` | Incrementa en 1 el valor numérico almacenado en la clave. | `INCR visitas:pagina` → aumenta el contador de visitas. |
| `DECR key` | Decrementa en 1 el valor numérico. | `DECR stock:producto123` → reduce el inventario. |
| `SETNX key value` | Crea una clave solo si no existe (Set if Not eXists). | `SETNX lock:pedido123 1` → útil para asegurar exclusividad o idempotencia. |
| `GETSET key value` | Asigna un nuevo valor y devuelve el anterior en una sola operación. | `GETSET temperatura:actual 28` → devuelve el valor previo antes de actualizar. |
| `EXPIRE key seconds` | Asigna un tiempo de vida a la clave (TTL). | `EXPIRE sesion:usuario45 900` → expira en 15 minutos. |
| `INCRBY key N` / `DECRBY key N` | Incrementa o decrementa el valor en una cantidad específica. | `INCRBY puntuacion:jugador 50` → suma 50 puntos. |
| `APPEND key value` | Agrega contenido al final del valor existente (útil para logs o mensajes). | `APPEND log:errores "Nuevo error detectado"` |

---

Estas operaciones permiten construir **comportamientos complejos de forma segura**, como:
- contadores concurrentes,  
- bloqueos distribuidos (*locks*),  
- mecanismos de idempotencia,  
- y expiración automática de datos.

---

## 3. Ventajas y desventajas

Las bases de datos clave-valor representan el modelo más simple y rápido dentro del ecosistema NoSQL. A diferencia de otros enfoques, como las bases de documentos (MongoDB), columnar (Cassandra) o de grafos (Neo4j), el modelo clave-valor prioriza la velocidad de acceso, la baja latencia y la simplicidad estructural, sacrificando características como la búsqueda avanzada o las relaciones complejas.

| ✅ **Ventajas** | **Descripción y comparación** |
|--------------|-------------------------------|
| **Simplicidad conceptual** | No requiere esquemas, tablas ni relaciones. Cada dato es un par `clave → valor`. Esto facilita el desarrollo y reduce el tiempo de configuración frente a modelos como MongoDB o Cassandra, que necesitan estructuras más definidas. |
| **Máximo rendimiento y baja latencia** | Al operar en memoria, bases como Redis alcanzan tiempos de respuesta de microsegundos. En comparación, las bases de documentos o grafos requieren parsers y planificadores de consultas más pesados. Ideal para sistemas de tiempo real. |
| **Escalabilidad horizontal sencilla** | Permiten distribuir los datos entre nodos (sharding) de forma natural, ya que las claves son independientes entre sí. En modelos de grafos o columnas, la distribución es más compleja por la interdependencia entre datos. |
| **Operaciones atómicas y seguras** | Comandos como `INCR`, `DECR`, `SETNX` o `EXPIRE` se ejecutan de forma atómica, garantizando integridad sin transacciones complejas. En bases documentales, lograr esa atomicidad requiere bloqueos o versiones de documento. |
| **Control de caducidad (TTL)** | Posibilidad de definir tiempo de vida por dato. Ideal para sesiones, tokens o cachés. Este comportamiento no está disponible nativamente en otros NoSQL, donde el manejo de expiración suele depender de procesos externos. |
| **Versatilidad de uso** | Puede actuar como caché, base temporal, broker de mensajes o soporte de analítica ligera, siendo complementaria a bases SQL o NoSQL más pesadas. |

---

| ⚠️ **Desventajas** | **Descripción y comparación** |
|-----------------|-------------------------------|
| **Limitada expresividad de consultas** | Solo permite recuperar información por clave exacta (`GET`). A diferencia de MongoDB o Elasticsearch, no soporta filtros, joins ni búsquedas por atributos. |
| **No apta para datos con relaciones** | No maneja relaciones ni jerarquías. En cambio, una base de grafos puede modelar redes complejas de usuarios, productos o conexiones. |
| **Dependencia de memoria** | Al residir en RAM, su capacidad está limitada al hardware disponible. Bases columnar o documentales pueden manejar terabytes en disco, aunque con mayor latencia. |
| **Persistencia opcional** | Redis ofrece modos de persistencia (*RDB*, *AOF*), pero no está diseñada para almacenamiento a largo plazo. Otras NoSQL como Cassandra o MongoDB garantizan durabilidad nativa. |
| **Modelo de datos rígido** | Aunque simple, el modelo clave-valor no admite anidamientos o estructuras complejas. Las bases de documentos permiten mayor flexibilidad en los valores y subcampos. |

---

Las bases clave-valor son la opción ideal cuando el objetivo principal es velocidad, simplicidad y respuesta inmediata, como en:
- sistemas de caching,  
- control de sesiones,  
- limitadores de peticiones (rate limiting),  
- almacenamiento temporal de datos.

> **En otras palabras:** las bases clave-valor no compiten por ofrecer más funciones, sino por ser las más rápidas y ligeras dentro del ecosistema NoSQL, complementando a las demás en arquitecturas distribuidas.


---

## 4. Redis como ejemplo de base de datos clave-valor  

**Redis (Remote Dictionary Server)** es un motor NoSQL en memoria que utiliza el modelo clave-valor y soporta diversas estructuras de datos: strings, listas, conjuntos, hashes y más.  
Redis puede configurarse como:
- **Cache:** para acelerar la respuesta de sistemas web.  
- **Base temporal:** para manejar sesiones o tokens efímeros.  
- **Contador en tiempo real:** para analítica o limitadores de tasa (*rate limiting*).  
- **Broker de mensajes:** usando *Pub/Sub*.  

Redis combina **velocidad**, **persistencia opcional** y **replicación** entre nodos, lo que lo hace ideal para entornos distribuidos y tolerantes a fallas.

---

## 5. Casos de uso y relación con los atributos de calidad  

Las bases de datos clave-valor son especialmente útiles en escenarios donde la rapidez de acceso, la simplicidad estructural y la capacidad de escalar horizontalmente son más importantes que las relaciones entre datos.  
A continuación se presentan algunos casos de uso reales donde este tipo de tecnología es más óptima que una base relacional, junto con los atributos de calidad que refuerza cada uno:

| **Caso de uso** | **Descripción y ejemplo** | **Atributos de calidad relacionados** |
|------------------|------------------------------------|--------------------------------------|
| **Caché de consultas** | Se utiliza para almacenar temporalmente los resultados de consultas costosas o muy frecuentes. Por ejemplo, una tienda en línea puede guardar en Redis los productos más vendidos o las categorías más consultadas para evitar consultas repetidas al motor SQL principal. Esto reduce drásticamente la latencia de respuesta al usuario. | **Rendimiento**, **Escalabilidad** |
| **Gestión de sesiones de usuario** | Redis permite guardar el estado de sesión de un usuario (token, preferencias o carrito) con un tiempo de expiración (`TTL`). Por ejemplo, en una aplicación web de banca digital, cada sesión puede tener una duración de 15 minutos, y Redis elimina automáticamente las sesiones inactivas. Esto garantiza seguridad y estabilidad sin intervención manual. | **Disponibilidad**, **Seguridad**, **Confiabilidad** |
| **Contadores en tiempo real** | Redis puede manejar incrementos atómicos para registrar visitas, likes o eventos simultáneos. Por ejemplo, una red social podría usarlo para contar el número de “me gusta” o visualizaciones de una publicación sin errores de concurrencia. | **Confiabilidad**, **Rendimiento** |
| **Rate limiter (limitador de peticiones)** | Se utiliza para evitar abusos del sistema controlando cuántas solicitudes puede hacer un usuario en un periodo de tiempo. Por ejemplo, una API pública puede permitir solo 100 peticiones por minuto; Redis cuenta los accesos y bloquea temporalmente al usuario si excede el límite. | **Seguridad**, **Disponibilidad**, **Rendimiento** |
| **Colas de procesamiento** | Redis puede usarse como intermediario entre productores y consumidores de tareas. Por ejemplo, un servicio de comercio electrónico puede encolar pedidos confirmados con `LPUSH`, y otro servicio (worker) los procesa en segundo plano con `RPOP`. Esto desacopla procesos y mejora la escalabilidad del sistema. | **Escalabilidad**, **Modificabilidad**, **Rendimiento** |
| **Feature flags o configuración dinámica** | Redis puede almacenar banderas que habilitan o deshabilitan funciones en producción sin necesidad de desplegar nuevamente el sistema. Por ejemplo, una plataforma educativa podría activar una nueva interfaz solo para el 10% de los usuarios durante un experimento A/B. | **Modificabilidad**, **Mantenibilidad**, **Disponibilidad** |

---

> En todos estos escenarios, Redis actúa como un **componente de soporte arquitectónico** que mejora el rendimiento y la elasticidad de los sistemas, permitiendo cumplir los objetivos de calidad sin introducir complejidad innecesaria.

---

## 6. Consideraciones técnicas 

### 6.1 Instalación y configuración de Redis

1. **Instalación usando Docker (recomendada para la demo)**  
   Redis se ejecutó en un contenedor Docker, lo que permitió un entorno limpio, reproducible y rápido de levantar.  
   ```bash
   docker run --name redis-demo -p 6379:6379 -d redis
   ```
   Este comando descarga la última imagen oficial de Redis y la expone en el puerto **6379**.  

2. **Verificación del servicio**  
   ```bash
   docker ps  # Confirma que el contenedor redis-demo está en ejecución
   docker exec -it redis-demo redis-cli ping  # → PONG
   ```

3. **Prueba básica de comandos**  
   ```bash
   docker exec -it redis-demo redis-cli
   SET demo:saludo "Hola Redis desde Docker"
   GET demo:saludo
   EXPIRE demo:saludo 10
   TTL demo:saludo
   ```

4. **Persistencia (opcional)**  
   Se puede montar un volumen para conservar los datos del contenedor:  
   ```bash
   docker run --name redis-demo -p 6379:6379 -v redis-data:/data -d redis redis-server --save 60 1 --loglevel warning
   ```
   Esto crea un volumen llamado `redis-data` y guarda snapshots automáticos cada minuto si hubo al menos una operación de escritura.  

### 6.2 Backend (Node.js + Express + ioredis)

1. **Inicializar proyecto**  
   ```bash
   mkdir -p hideki-url-shortener/backend
   cd hideki-url-shortener/backend
   npm init -y
   npm install express ioredis cors dotenv nanoid@3
   npm install --save-dev nodemon
   ```

2. **Variables de entorno (.env)**  
   ```env
   PORT=3000
   REDIS_HOST=127.0.0.1
   REDIS_PORT=6379
   BASE_URL=http://localhost:3000
   URL_TTL_SECONDS=604800
   ```

3. **Script de ejecución**  
   ```json
   "scripts": { "start": "nodemon server.js" }
   ```

4. **Conexión a Redis**  
   ```js
   const Redis = require('ioredis');
   const redis = new Redis({ host: process.env.REDIS_HOST, port: process.env.REDIS_PORT });
   ```

5. **Comandos Redis usados en la demo**  
   - `SET`, `GET`, `EXPIRE`, `INCR`, `DEL`, `HSET`, `HGETALL`, `SCAN`  
   - Se emplearon operaciones **atómicas** para crear URLs, TTL y contadores.

6. **Ejecución del backend**  
   ```bash
   npm start
   ```
   Salida esperada:  
   ```bash
   🚀 API escuchando en http://localhost:3000
   ```

### 6.3 Frontend (React + TypeScript + Tailwind)

1. **Crear proyecto**  
   ```bash
   cd ..
   npm create vite@latest frontend -- --template react-ts
   cd frontend && npm install
   ```

2. **Instalar dependencias**  
   ```bash
   npm install lucide-react tailwindcss postcss autoprefixer sonner
   npx tailwindcss init -p
   ```

3. **Configurar Tailwind**  
   `tailwind.config.js`:
   ```js
   export default {
     content: ["./index.html", "./src/**/*.{ts,tsx}"],
     theme: { extend: {} },
     plugins: [],
   };
   ```

4. **Variable de entorno del front**  
   `.env`:
   ```env
   VITE_API_BASE=http://localhost:3000
   ```

5. **Ejecutar el frontend**  
   ```bash
   npm run dev  # → http://localhost:5173
   ```

6. **Endpoints del backend consumidos por el front**  
   - `POST /api/shorten` → crea URL corta.  
   - `GET /api/list` → lista URLs vigentes.  
   - `GET /api/stats/:code` → estadísticas.  
   - `DELETE /api/url/:code` → elimina claves asociadas.

### 6.4 Flujo de funcionamiento de la demo  

1. El usuario ingresa una **URL larga** en el frontend.  
2. El backend genera un **código aleatorio (nanoid)** y ejecuta:  
   ```bash
   SET url:abc123 https://ulima.edu.pe EX 604800
   SETNX clicks:abc123 0
   HSET meta:abc123 created_at "2025-10-11" ttl_seconds "604800"
   ```
3. Cada clic ejecuta:  
   ```bash
   INCR clicks:abc123
   ```
4. El front consulta `/api/list` y muestra las URLs activas.  
5. Si una URL expira, Redis la elimina automáticamente.

### 6.5 Arquitectura simplificada  

```text
┌──────────────────────────────┐
│        Interfaz Web (TSX)    │
│  React + Tailwind + Sonner   │
└──────────────┬───────────────┘
               │ Fetch API REST
               ▼
┌──────────────────────────────┐
│     Backend Node.js (Express)│
│  Endpoints: /shorten /list   │
└──────────────┬───────────────┘
               │ ioredis client
               ▼
┌──────────────────────────────┐
│        Redis Server (NoSQL)  │
│  SET / GET / EXPIRE / INCR   │
└──────────────────────────────┘
```
### 🧱 6.6 Resultados obtenidos  

- Redis mostró latencia **<1ms** en operaciones básicas.  
- Contadores de clics atómicos y consistentes.  
- TTL garantizó limpieza automática.  
- El sistema evidenció los atributos:  
  - **Rendimiento:** respuestas inmediatas.  
  - **Escalabilidad:** separación por claves.  
  - **Disponibilidad:** autogestión del ciclo de vida.  

---

## 7. Ejemplo de implementación (Demo)

La demo desarrollada consiste en una **aplicación web funcional** que implementa un sistema de **acortamiento de URLs temporales** utilizando **Redis** como base de datos clave-valor.  
El objetivo es demostrar, de manera práctica, cómo los comandos básicos de Redis pueden emplearse para construir un servicio eficiente, rápido y con mecanismos automáticos de control de ciclo de vida de los datos.

El sistema está compuesto por tres capas principales:

1. **Frontend (React + TypeScript):**  
   - Interfaz web donde el usuario puede ingresar una URL larga para obtener su versión acortada.  
   - Muestra estadísticas en tiempo real del enlace (clics totales, TTL restante, fecha de creación).  
   - Permite listar todos los enlaces almacenados, eliminarlos manualmente y visualizar métricas de rendimiento del backend y de Redis.  

2. **Backend (Node.js + Express + ioredis):**  
   - Expone una API REST que recibe solicitudes del frontend y ejecuta operaciones atómicas en Redis.  
   - Cada URL acortada se almacena como un par clave-valor (`url:codigo → URL original`), con un tiempo de vida limitado (TTL) mediante el comando `EXPIRE`.  
   - Cada acceso incrementa un contador asociado (`clicks:codigo`) mediante el comando `INCR`, garantizando conteo atómico sin bloqueos ni colisiones de concurrencia.  
   - Incluye endpoints adicionales para listar URLs vigentes, obtener estadísticas, eliminar enlaces y consultar métricas de rendimiento (latencia de backend y Redis).  

3. **Base de datos Redis:**  
   - Funciona como un almacén en memoria que gestiona los pares `clave → valor` de forma extremadamente rápida.  
   - Las claves se estructuran de manera jerárquica (`url:`, `clicks:`, `meta:`) para facilitar la organización y recuperación de información.  
   - Implementa la caducidad automática de las URLs mediante TTL, eliminando registros expirados sin intervención manual.  

### **Flujo general del sistema**

1. El usuario ingresa una URL larga desde la interfaz web y solicita acortarla.  
2. El backend genera un código corto único (utilizando `nanoid`) y ejecuta en Redis:  
   ```bash
   SET url:abc123 https://ulima.edu.pe EX 604800
   SETNX clicks:abc123 0
   HSET meta:abc123 created_at "2025-10-11T..." ttl_seconds "604800"
   ```
3. Redis almacena la URL y su metadata con un tiempo de vida de 7 días (TTL = 604800 segundos).  
4. Cada vez que un usuario accede al enlace corto (`http://localhost:3000/abc123`), Redis incrementa el contador:  
   ```bash
   INCR clicks:abc123
   ```
   garantizando una actualización segura y atómica incluso bajo múltiples solicitudes simultáneas.  
5. El frontend consulta los endpoints `/api/list` y `/api/stats/:code` para mostrar las estadísticas actualizadas, y `/api/url/:code` para eliminar enlaces.  
6. Además, se añadió un endpoint `/api/performance` que devuelve métricas de latencia del backend y del acceso a Redis, las cuales se visualizan en una card especial dentro del panel web.  

### **Objetivos demostrados**

- **`SET` / `GET`:** demuestran el almacenamiento y recuperación de datos en un modelo clave-valor simple y eficiente.  
- **`EXPIRE`:** permite la eliminación automática de URLs caducadas, mostrando cómo Redis maneja la memoria de forma autónoma.  
- **`INCR`:** ejemplifica las operaciones atómicas y concurrentes, fundamentales para métricas en tiempo real.  
- **`SCAN` y `DEL`:** empleados para listar y eliminar claves asociadas sin comprometer el rendimiento.  
- **Métricas de rendimiento:** mediante la API `/api/performance`, se evalúan los tiempos promedio de respuesta del backend y la latencia de Redis, reforzando el atributo de calidad **rendimiento**.

### **Enlace al video de presentacion**

https://www.youtube.com/watch?v=ebgogRsY5I8

---

## 8. Conclusiones  

El uso de bases de datos NoSQL clave-valor como Redis evidencia cómo una táctica arquitectónica bien seleccionada puede impactar  en los atributos de calidad del sistema.  

- **Rendimiento:** Redis, al operar en memoria, reduce significativamente la latencia de acceso a los datos y permite tiempos de respuesta de microsegundos, cumpliendo con los requisitos de desempeño para sistemas de alta demanda.  
- **Disponibilidad:** gracias al uso de TTL y mecanismos de replicación opcionales, Redis garantiza que los datos más relevantes estén disponibles de manera inmediata, incluso ante fallos parciales o picos de tráfico.  
- **Escalabilidad:** el modelo clave-valor permite distribuir fácilmente las claves entre múltiples nodos, habilitando el crecimiento horizontal sin alterar la lógica de la aplicación.  
- **Confiabilidad:** las operaciones atómicas (`INCR`, `SETNX`, `DEL`) aseguran integridad en entornos concurrentes sin necesidad de transacciones complejas.  
- **Modificabilidad y mantenibilidad:** la simplicidad del modelo y la independencia entre claves facilitan la extensión o sustitución de funcionalidades sin afectar otras partes del sistema.  
- **Seguridad:** mediante la caducidad automática de datos sensibles (tokens, sesiones), Redis contribuye a reducir la exposición y el riesgo de accesos no autorizados.  

En conjunto, la táctica demuestra cómo una solución ligera como Redis puede fortalecer atributos de calidad esenciales, funcionando como un componente de soporte arquitectónico que incrementa la eficiencia, estabilidad y robustez del sistema global.  


---

## 9. Referencias  

- Bass, L., Clements, P., & Kazman, R. (2013). *Software Architecture in Practice*. Addison-Wesley.  
- Redis Labs. (2024). *Redis Documentation*. [https://redis.io/docs](https://redis.io/docs)  
- Fowler, M. (2020). *NoSQL Databases and Polyglot Persistence.* ThoughtWorks.  


[⬅️ Anterior](../0.6.3/0.6.3.md) | [🏠 Home](../../../README.md) | [Siguiente ➡️](../0.6.5/0.6.5.md)

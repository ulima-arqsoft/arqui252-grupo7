> [0. Acerca del Grupo](../../0.md) â€º [0.6. Temas Individuales (Parte 1)](../0.6.md) â€º [0.6.4. Integrante 4](0.6.4.md)

# 0.6.4. Integrante 4

# Informe Individual â€“ TÃ¡ctica: Uso de Bases de Datos NoSQL Clave-Valor  

**Nombre:** Hideki Sotero Huaroto  
**Curso:** Arquitectura de Software  
**Docente:** Jose Caballero Ortiz  
**Tema aprobado:** Bases de datos NoSQL clave-valor

---

## 1. IntroducciÃ³n  

En el contexto de la arquitectura de software moderna, los sistemas deben manejar grandes volÃºmenes de datos con alta velocidad, disponibilidad y escalabilidad.  
Las bases de datos tradicionales relacionales (SQL) pueden presentar limitaciones ante estas necesidades, especialmente cuando los datos son altamente dinÃ¡micos, no estructurados o requieren una latencia muy baja.  

Las bases de datos NoSQL surgen como una alternativa flexible que permite diferentes modelos de almacenamiento. Entre ellos, las bases de datos clave-valor destacan por su simplicidad y alto rendimiento, convirtiÃ©ndose en una pieza esencial en arquitecturas de microservicios, caching y sistemas de tiempo real.  

---

## 2. Concepto de bases de datos NoSQL clave-valor  

Una base de datos clave-valor almacena la informaciÃ³n como pares Ãºnicos de clave y valor, donde la clave actÃºa como un identificador y el valor puede ser cualquier tipo de dato (texto, nÃºmero, JSON u objeto binario).  

> **Ejemplo:**  
> `user:1001 â†’ {"nombre": "LucÃ­a", "edad": 25}`

El acceso a la informaciÃ³n se realiza mediante operaciones simples:  
- `SET` para escribir.  
- `GET` para leer.  
- `DEL` para eliminar.  

A diferencia de las bases relacionales, este tipo de sistema no necesita un esquema fijo ni realiza consultas complejas, priorizando la **velocidad y eficiencia** sobre la estructura.

### Operaciones atÃ³micas en bases de datos clave-valor

Las bases de datos clave-valor, como Redis, ofrecen **operaciones atÃ³micas**, es decir, acciones que se ejecutan completamente o no se ejecutan en absoluto, evitando conflictos cuando mÃºltiples clientes acceden a la misma clave simultÃ¡neamente.  
Estas operaciones garantizan **consistencia y seguridad** sin necesidad de mecanismos de bloqueo ni transacciones complejas.

Algunas de las operaciones atÃ³micas mÃ¡s comunes son:

| **Comando** | **DescripciÃ³n** | **Ejemplo** |
|--------------|----------------|--------------|
| `INCR key` | Incrementa en 1 el valor numÃ©rico almacenado en la clave. | `INCR visitas:pagina` â†’ aumenta el contador de visitas. |
| `DECR key` | Decrementa en 1 el valor numÃ©rico. | `DECR stock:producto123` â†’ reduce el inventario. |
| `SETNX key value` | Crea una clave solo si no existe (Set if Not eXists). | `SETNX lock:pedido123 1` â†’ Ãºtil para asegurar exclusividad o idempotencia. |
| `GETSET key value` | Asigna un nuevo valor y devuelve el anterior en una sola operaciÃ³n. | `GETSET temperatura:actual 28` â†’ devuelve el valor previo antes de actualizar. |
| `EXPIRE key seconds` | Asigna un tiempo de vida a la clave (TTL). | `EXPIRE sesion:usuario45 900` â†’ expira en 15 minutos. |
| `INCRBY key N` / `DECRBY key N` | Incrementa o decrementa el valor en una cantidad especÃ­fica. | `INCRBY puntuacion:jugador 50` â†’ suma 50 puntos. |
| `APPEND key value` | Agrega contenido al final del valor existente (Ãºtil para logs o mensajes). | `APPEND log:errores "Nuevo error detectado"` |

---

Estas operaciones permiten construir **comportamientos complejos de forma segura**, como:
- contadores concurrentes,  
- bloqueos distribuidos (*locks*),  
- mecanismos de idempotencia,  
- y expiraciÃ³n automÃ¡tica de datos.

---

## 3. Ventajas y desventajas

Las bases de datos clave-valor representan el modelo mÃ¡s simple y rÃ¡pido dentro del ecosistema NoSQL. A diferencia de otros enfoques, como las bases de documentos (MongoDB), columnar (Cassandra) o de grafos (Neo4j), el modelo clave-valor prioriza la velocidad de acceso, la baja latencia y la simplicidad estructural, sacrificando caracterÃ­sticas como la bÃºsqueda avanzada o las relaciones complejas.

| âœ… **Ventajas** | **DescripciÃ³n y comparaciÃ³n** |
|--------------|-------------------------------|
| **Simplicidad conceptual** | No requiere esquemas, tablas ni relaciones. Cada dato es un par `clave â†’ valor`. Esto facilita el desarrollo y reduce el tiempo de configuraciÃ³n frente a modelos como MongoDB o Cassandra, que necesitan estructuras mÃ¡s definidas. |
| **MÃ¡ximo rendimiento y baja latencia** | Al operar en memoria, bases como Redis alcanzan tiempos de respuesta de microsegundos. En comparaciÃ³n, las bases de documentos o grafos requieren parsers y planificadores de consultas mÃ¡s pesados. Ideal para sistemas de tiempo real. |
| **Escalabilidad horizontal sencilla** | Permiten distribuir los datos entre nodos (sharding) de forma natural, ya que las claves son independientes entre sÃ­. En modelos de grafos o columnas, la distribuciÃ³n es mÃ¡s compleja por la interdependencia entre datos. |
| **Operaciones atÃ³micas y seguras** | Comandos como `INCR`, `DECR`, `SETNX` o `EXPIRE` se ejecutan de forma atÃ³mica, garantizando integridad sin transacciones complejas. En bases documentales, lograr esa atomicidad requiere bloqueos o versiones de documento. |
| **Control de caducidad (TTL)** | Posibilidad de definir tiempo de vida por dato. Ideal para sesiones, tokens o cachÃ©s. Este comportamiento no estÃ¡ disponible nativamente en otros NoSQL, donde el manejo de expiraciÃ³n suele depender de procesos externos. |
| **Versatilidad de uso** | Puede actuar como cachÃ©, base temporal, broker de mensajes o soporte de analÃ­tica ligera, siendo complementaria a bases SQL o NoSQL mÃ¡s pesadas. |

---

| âš ï¸ **Desventajas** | **DescripciÃ³n y comparaciÃ³n** |
|-----------------|-------------------------------|
| **Limitada expresividad de consultas** | Solo permite recuperar informaciÃ³n por clave exacta (`GET`). A diferencia de MongoDB o Elasticsearch, no soporta filtros, joins ni bÃºsquedas por atributos. |
| **No apta para datos con relaciones** | No maneja relaciones ni jerarquÃ­as. En cambio, una base de grafos puede modelar redes complejas de usuarios, productos o conexiones. |
| **Dependencia de memoria** | Al residir en RAM, su capacidad estÃ¡ limitada al hardware disponible. Bases columnar o documentales pueden manejar terabytes en disco, aunque con mayor latencia. |
| **Persistencia opcional** | Redis ofrece modos de persistencia (*RDB*, *AOF*), pero no estÃ¡ diseÃ±ada para almacenamiento a largo plazo. Otras NoSQL como Cassandra o MongoDB garantizan durabilidad nativa. |
| **Modelo de datos rÃ­gido** | Aunque simple, el modelo clave-valor no admite anidamientos o estructuras complejas. Las bases de documentos permiten mayor flexibilidad en los valores y subcampos. |

---

Las bases clave-valor son la opciÃ³n ideal cuando el objetivo principal es velocidad, simplicidad y respuesta inmediata, como en:
- sistemas de caching,  
- control de sesiones,  
- limitadores de peticiones (rate limiting),  
- almacenamiento temporal de datos.

> **En otras palabras:** las bases clave-valor no compiten por ofrecer mÃ¡s funciones, sino por ser las mÃ¡s rÃ¡pidas y ligeras dentro del ecosistema NoSQL, complementando a las demÃ¡s en arquitecturas distribuidas.


---

## 4. Redis como ejemplo de base de datos clave-valor  

**Redis (Remote Dictionary Server)** es un motor NoSQL en memoria que utiliza el modelo clave-valor y soporta diversas estructuras de datos: strings, listas, conjuntos, hashes y mÃ¡s.  
Redis puede configurarse como:
- **Cache:** para acelerar la respuesta de sistemas web.  
- **Base temporal:** para manejar sesiones o tokens efÃ­meros.  
- **Contador en tiempo real:** para analÃ­tica o limitadores de tasa (*rate limiting*).  
- **Broker de mensajes:** usando *Pub/Sub*.  

Redis combina **velocidad**, **persistencia opcional** y **replicaciÃ³n** entre nodos, lo que lo hace ideal para entornos distribuidos y tolerantes a fallas.

---

## 5. Casos de uso y relaciÃ³n con los atributos de calidad  

Las bases de datos clave-valor son especialmente Ãºtiles en escenarios donde la rapidez de acceso, la simplicidad estructural y la capacidad de escalar horizontalmente son mÃ¡s importantes que las relaciones entre datos.  
A continuaciÃ³n se presentan algunos casos de uso reales donde este tipo de tecnologÃ­a es mÃ¡s Ã³ptima que una base relacional, junto con los atributos de calidad que refuerza cada uno:

| **Caso de uso** | **DescripciÃ³n y ejemplo** | **Atributos de calidad relacionados** |
|------------------|------------------------------------|--------------------------------------|
| **CachÃ© de consultas** | Se utiliza para almacenar temporalmente los resultados de consultas costosas o muy frecuentes. Por ejemplo, una tienda en lÃ­nea puede guardar en Redis los productos mÃ¡s vendidos o las categorÃ­as mÃ¡s consultadas para evitar consultas repetidas al motor SQL principal. Esto reduce drÃ¡sticamente la latencia de respuesta al usuario. | **Rendimiento**, **Escalabilidad** |
| **GestiÃ³n de sesiones de usuario** | Redis permite guardar el estado de sesiÃ³n de un usuario (token, preferencias o carrito) con un tiempo de expiraciÃ³n (`TTL`). Por ejemplo, en una aplicaciÃ³n web de banca digital, cada sesiÃ³n puede tener una duraciÃ³n de 15 minutos, y Redis elimina automÃ¡ticamente las sesiones inactivas. Esto garantiza seguridad y estabilidad sin intervenciÃ³n manual. | **Disponibilidad**, **Seguridad**, **Confiabilidad** |
| **Contadores en tiempo real** | Redis puede manejar incrementos atÃ³micos para registrar visitas, likes o eventos simultÃ¡neos. Por ejemplo, una red social podrÃ­a usarlo para contar el nÃºmero de â€œme gustaâ€ o visualizaciones de una publicaciÃ³n sin errores de concurrencia. | **Confiabilidad**, **Rendimiento** |
| **Rate limiter (limitador de peticiones)** | Se utiliza para evitar abusos del sistema controlando cuÃ¡ntas solicitudes puede hacer un usuario en un periodo de tiempo. Por ejemplo, una API pÃºblica puede permitir solo 100 peticiones por minuto; Redis cuenta los accesos y bloquea temporalmente al usuario si excede el lÃ­mite. | **Seguridad**, **Disponibilidad**, **Rendimiento** |
| **Colas de procesamiento** | Redis puede usarse como intermediario entre productores y consumidores de tareas. Por ejemplo, un servicio de comercio electrÃ³nico puede encolar pedidos confirmados con `LPUSH`, y otro servicio (worker) los procesa en segundo plano con `RPOP`. Esto desacopla procesos y mejora la escalabilidad del sistema. | **Escalabilidad**, **Modificabilidad**, **Rendimiento** |
| **Feature flags o configuraciÃ³n dinÃ¡mica** | Redis puede almacenar banderas que habilitan o deshabilitan funciones en producciÃ³n sin necesidad de desplegar nuevamente el sistema. Por ejemplo, una plataforma educativa podrÃ­a activar una nueva interfaz solo para el 10% de los usuarios durante un experimento A/B. | **Modificabilidad**, **Mantenibilidad**, **Disponibilidad** |

---

> En todos estos escenarios, Redis actÃºa como un **componente de soporte arquitectÃ³nico** que mejora el rendimiento y la elasticidad de los sistemas, permitiendo cumplir los objetivos de calidad sin introducir complejidad innecesaria.

---

## 6. Consideraciones tÃ©cnicas 

### 6.1 InstalaciÃ³n y configuraciÃ³n de Redis

1. **InstalaciÃ³n usando Docker (recomendada para la demo)**  
   Redis se ejecutÃ³ en un contenedor Docker, lo que permitiÃ³ un entorno limpio, reproducible y rÃ¡pido de levantar.  
   ```bash
   docker run --name redis-demo -p 6379:6379 -d redis
   ```
   Este comando descarga la Ãºltima imagen oficial de Redis y la expone en el puerto **6379**.  

2. **VerificaciÃ³n del servicio**  
   ```bash
   docker ps  # Confirma que el contenedor redis-demo estÃ¡ en ejecuciÃ³n
   docker exec -it redis-demo redis-cli ping  # â†’ PONG
   ```

3. **Prueba bÃ¡sica de comandos**  
   ```bash
   docker exec -it redis-demo redis-cli
   SET demo:saludo "Hola Redis desde Docker"
   GET demo:saludo
   EXPIRE demo:saludo 10
   TTL demo:saludo
   ```

4. **Persistencia (opcional)**  
   Se puede montar un volumen para conservar los datos del contenedor:  
   ```bash
   docker run --name redis-demo -p 6379:6379 -v redis-data:/data -d redis redis-server --save 60 1 --loglevel warning
   ```
   Esto crea un volumen llamado `redis-data` y guarda snapshots automÃ¡ticos cada minuto si hubo al menos una operaciÃ³n de escritura.  

### 6.2 Backend (Node.js + Express + ioredis)

1. **Inicializar proyecto**  
   ```bash
   mkdir -p hideki-url-shortener/backend
   cd hideki-url-shortener/backend
   npm init -y
   npm install express ioredis cors dotenv nanoid@3
   npm install --save-dev nodemon
   ```

2. **Variables de entorno (.env)**  
   ```env
   PORT=3000
   REDIS_HOST=127.0.0.1
   REDIS_PORT=6379
   BASE_URL=http://localhost:3000
   URL_TTL_SECONDS=604800
   ```

3. **Script de ejecuciÃ³n**  
   ```json
   "scripts": { "start": "nodemon server.js" }
   ```

4. **ConexiÃ³n a Redis**  
   ```js
   const Redis = require('ioredis');
   const redis = new Redis({ host: process.env.REDIS_HOST, port: process.env.REDIS_PORT });
   ```

5. **Comandos Redis usados en la demo**  
   - `SET`, `GET`, `EXPIRE`, `INCR`, `DEL`, `HSET`, `HGETALL`, `SCAN`  
   - Se emplearon operaciones **atÃ³micas** para crear URLs, TTL y contadores.

6. **EjecuciÃ³n del backend**  
   ```bash
   npm start
   ```
   Salida esperada:  
   ```bash
   ğŸš€ API escuchando en http://localhost:3000
   ```

### 6.3 Frontend (React + TypeScript + Tailwind)

1. **Crear proyecto**  
   ```bash
   cd ..
   npm create vite@latest frontend -- --template react-ts
   cd frontend && npm install
   ```

2. **Instalar dependencias**  
   ```bash
   npm install lucide-react tailwindcss postcss autoprefixer sonner
   npx tailwindcss init -p
   ```

3. **Configurar Tailwind**  
   `tailwind.config.js`:
   ```js
   export default {
     content: ["./index.html", "./src/**/*.{ts,tsx}"],
     theme: { extend: {} },
     plugins: [],
   };
   ```

4. **Variable de entorno del front**  
   `.env`:
   ```env
   VITE_API_BASE=http://localhost:3000
   ```

5. **Ejecutar el frontend**  
   ```bash
   npm run dev  # â†’ http://localhost:5173
   ```

6. **Endpoints del backend consumidos por el front**  
   - `POST /api/shorten` â†’ crea URL corta.  
   - `GET /api/list` â†’ lista URLs vigentes.  
   - `GET /api/stats/:code` â†’ estadÃ­sticas.  
   - `DELETE /api/url/:code` â†’ elimina claves asociadas.

### 6.4 Flujo de funcionamiento de la demo  

1. El usuario ingresa una **URL larga** en el frontend.  
2. El backend genera un **cÃ³digo aleatorio (nanoid)** y ejecuta:  
   ```bash
   SET url:abc123 https://ulima.edu.pe EX 604800
   SETNX clicks:abc123 0
   HSET meta:abc123 created_at "2025-10-11" ttl_seconds "604800"
   ```
3. Cada clic ejecuta:  
   ```bash
   INCR clicks:abc123
   ```
4. El front consulta `/api/list` y muestra las URLs activas.  
5. Si una URL expira, Redis la elimina automÃ¡ticamente.

### 6.5 Arquitectura simplificada  

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Interfaz Web (TSX)    â”‚
â”‚  React + Tailwind + Sonner   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ Fetch API REST
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Backend Node.js (Express)â”‚
â”‚  Endpoints: /shorten /list   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ ioredis client
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Redis Server (NoSQL)  â”‚
â”‚  SET / GET / EXPIRE / INCR   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```
### ğŸ§± 6.6 Resultados obtenidos  

- Redis mostrÃ³ latencia **<1ms** en operaciones bÃ¡sicas.  
- Contadores de clics atÃ³micos y consistentes.  
- TTL garantizÃ³ limpieza automÃ¡tica.  
- El sistema evidenciÃ³ los atributos:  
  - **Rendimiento:** respuestas inmediatas.  
  - **Escalabilidad:** separaciÃ³n por claves.  
  - **Disponibilidad:** autogestiÃ³n del ciclo de vida.  

---

## 7. Ejemplo de implementaciÃ³n (Demo)

La demo desarrollada consiste en una **aplicaciÃ³n web funcional** que implementa un sistema de **acortamiento de URLs temporales** utilizando **Redis** como base de datos clave-valor.  
El objetivo es demostrar, de manera prÃ¡ctica, cÃ³mo los comandos bÃ¡sicos de Redis pueden emplearse para construir un servicio eficiente, rÃ¡pido y con mecanismos automÃ¡ticos de control de ciclo de vida de los datos.

El sistema estÃ¡ compuesto por tres capas principales:

1. **Frontend (React + TypeScript):**  
   - Interfaz web donde el usuario puede ingresar una URL larga para obtener su versiÃ³n acortada.  
   - Muestra estadÃ­sticas en tiempo real del enlace (clics totales, TTL restante, fecha de creaciÃ³n).  
   - Permite listar todos los enlaces almacenados, eliminarlos manualmente y visualizar mÃ©tricas de rendimiento del backend y de Redis.  

2. **Backend (Node.js + Express + ioredis):**  
   - Expone una API REST que recibe solicitudes del frontend y ejecuta operaciones atÃ³micas en Redis.  
   - Cada URL acortada se almacena como un par clave-valor (`url:codigo â†’ URL original`), con un tiempo de vida limitado (TTL) mediante el comando `EXPIRE`.  
   - Cada acceso incrementa un contador asociado (`clicks:codigo`) mediante el comando `INCR`, garantizando conteo atÃ³mico sin bloqueos ni colisiones de concurrencia.  
   - Incluye endpoints adicionales para listar URLs vigentes, obtener estadÃ­sticas, eliminar enlaces y consultar mÃ©tricas de rendimiento (latencia de backend y Redis).  

3. **Base de datos Redis:**  
   - Funciona como un almacÃ©n en memoria que gestiona los pares `clave â†’ valor` de forma extremadamente rÃ¡pida.  
   - Las claves se estructuran de manera jerÃ¡rquica (`url:`, `clicks:`, `meta:`) para facilitar la organizaciÃ³n y recuperaciÃ³n de informaciÃ³n.  
   - Implementa la caducidad automÃ¡tica de las URLs mediante TTL, eliminando registros expirados sin intervenciÃ³n manual.  

### **Flujo general del sistema**

1. El usuario ingresa una URL larga desde la interfaz web y solicita acortarla.  
2. El backend genera un cÃ³digo corto Ãºnico (utilizando `nanoid`) y ejecuta en Redis:  
   ```bash
   SET url:abc123 https://ulima.edu.pe EX 604800
   SETNX clicks:abc123 0
   HSET meta:abc123 created_at "2025-10-11T..." ttl_seconds "604800"
   ```
3. Redis almacena la URL y su metadata con un tiempo de vida de 7 dÃ­as (TTL = 604800 segundos).  
4. Cada vez que un usuario accede al enlace corto (`http://localhost:3000/abc123`), Redis incrementa el contador:  
   ```bash
   INCR clicks:abc123
   ```
   garantizando una actualizaciÃ³n segura y atÃ³mica incluso bajo mÃºltiples solicitudes simultÃ¡neas.  
5. El frontend consulta los endpoints `/api/list` y `/api/stats/:code` para mostrar las estadÃ­sticas actualizadas, y `/api/url/:code` para eliminar enlaces.  
6. AdemÃ¡s, se aÃ±adiÃ³ un endpoint `/api/performance` que devuelve mÃ©tricas de latencia del backend y del acceso a Redis, las cuales se visualizan en una card especial dentro del panel web.  

### **Objetivos demostrados**

- **`SET` / `GET`:** demuestran el almacenamiento y recuperaciÃ³n de datos en un modelo clave-valor simple y eficiente.  
- **`EXPIRE`:** permite la eliminaciÃ³n automÃ¡tica de URLs caducadas, mostrando cÃ³mo Redis maneja la memoria de forma autÃ³noma.  
- **`INCR`:** ejemplifica las operaciones atÃ³micas y concurrentes, fundamentales para mÃ©tricas en tiempo real.  
- **`SCAN` y `DEL`:** empleados para listar y eliminar claves asociadas sin comprometer el rendimiento.  
- **MÃ©tricas de rendimiento:** mediante la API `/api/performance`, se evalÃºan los tiempos promedio de respuesta del backend y la latencia de Redis, reforzando el atributo de calidad **rendimiento**.

### **Enlace al video de presentacion**

https://www.youtube.com/watch?v=ebgogRsY5I8

---

## 8. Conclusiones  

El uso de bases de datos NoSQL clave-valor como Redis evidencia cÃ³mo una tÃ¡ctica arquitectÃ³nica bien seleccionada puede impactar  en los atributos de calidad del sistema.  

- **Rendimiento:** Redis, al operar en memoria, reduce significativamente la latencia de acceso a los datos y permite tiempos de respuesta de microsegundos, cumpliendo con los requisitos de desempeÃ±o para sistemas de alta demanda.  
- **Disponibilidad:** gracias al uso de TTL y mecanismos de replicaciÃ³n opcionales, Redis garantiza que los datos mÃ¡s relevantes estÃ©n disponibles de manera inmediata, incluso ante fallos parciales o picos de trÃ¡fico.  
- **Escalabilidad:** el modelo clave-valor permite distribuir fÃ¡cilmente las claves entre mÃºltiples nodos, habilitando el crecimiento horizontal sin alterar la lÃ³gica de la aplicaciÃ³n.  
- **Confiabilidad:** las operaciones atÃ³micas (`INCR`, `SETNX`, `DEL`) aseguran integridad en entornos concurrentes sin necesidad de transacciones complejas.  
- **Modificabilidad y mantenibilidad:** la simplicidad del modelo y la independencia entre claves facilitan la extensiÃ³n o sustituciÃ³n de funcionalidades sin afectar otras partes del sistema.  
- **Seguridad:** mediante la caducidad automÃ¡tica de datos sensibles (tokens, sesiones), Redis contribuye a reducir la exposiciÃ³n y el riesgo de accesos no autorizados.  

En conjunto, la tÃ¡ctica demuestra cÃ³mo una soluciÃ³n ligera como Redis puede fortalecer atributos de calidad esenciales, funcionando como un componente de soporte arquitectÃ³nico que incrementa la eficiencia, estabilidad y robustez del sistema global.  


---

## 9. Referencias  

- Bass, L., Clements, P., & Kazman, R. (2013). *Software Architecture in Practice*. Addison-Wesley.  
- Redis Labs. (2024). *Redis Documentation*. [https://redis.io/docs](https://redis.io/docs)  
- Fowler, M. (2020). *NoSQL Databases and Polyglot Persistence.* ThoughtWorks.  


[â¬…ï¸ Anterior](../0.6.3/0.6.3.md) | [ğŸ  Home](../../../README.md) | [Siguiente â¡ï¸](../0.6.5/0.6.5.md)

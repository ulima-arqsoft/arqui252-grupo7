> [0. Acerca del Grupo](../../0.md) â€º [0.7. Trabajo Individual (Patrones Cloud)](../0.7.md) â€º [0.7.1. Integrante 1](0.7.1.md)

# 0.7.1. Integrante 1

El patrÃ³n **Backends for Frontends** (BFF) es un patrÃ³n arquitectÃ³nico que propone crear backends especializados para cada tipo de interfaz de usuario (web, mÃ³vil, desktop).  
Su propÃ³sito principal es optimizar la experiencia del usuario proporcionando APIs especÃ­ficas adaptadas a las capacidades y restricciones de cada cliente, evitando la complejidad de un backend monolÃ­tico que intenta servir a todos los frontends simultÃ¡neamente.

--- 

## 2. Problema

En una arquitectura tradicional, un **Ãºnico backend** sirve a mÃºltiples tipos de clientes: aplicaciones web, mÃ³viles, desktop, smartwatches, etc.  
Esto genera varios problemas:

- **Sobrecarga del backend compartido**: El servicio debe manejar lÃ³gica especÃ­fica para cada cliente, aumentando su complejidad.
- **Conflictos entre equipos**: Los equipos frontend de web y mÃ³vil compiten por recursos y prioridades en el backend.
- **Compromiso en la experiencia de usuario**: Las APIs deben ser genÃ©ricas, sacrificando optimizaciones especÃ­ficas de cada plataforma.
- **Cuellos de botella en desarrollo**: Cada cambio requiere coordinaciÃ³n entre mÃºltiples equipos y validaciÃ³n cruzada.
- **Sobrefetching/Underfetching**: El cliente web puede necesitar mÃ¡s datos que el mÃ³vil, generando transferencias innecesarias o mÃºltiples peticiones.

En un **e-commerce**, la aplicaciÃ³n mÃ³vil necesita respuestas ligeras y paginadas para conservar ancho de banda, mientras que la web puede cargar mÃºltiples productos, imÃ¡genes de alta resoluciÃ³n y secciones completas en una sola peticiÃ³n.

---

## 3. SoluciÃ³n: PatrÃ³n Backends for Frontends (BFF)

El patrÃ³n propone crear un **backend dedicado para cada tipo de frontend**, actuando como una capa intermedia entre el cliente y los microservicios backend.

### Estructura bÃ¡sica:

1. **Cliente Web (React/Vite)**  
   Se comunica con su propio BFF optimizado para experiencias de escritorio.  
   Obtiene respuestas con **todos los productos** (84 productos) en una sola peticiÃ³n, con imÃ¡genes de alta resoluciÃ³n y datos completos.

2. **Cliente MÃ³vil (SwiftUI - iOS)**  
   Se comunica con su propio BFF optimizado para dispositivos mÃ³viles.  
   Obtiene respuestas **paginadas** (10 productos por pÃ¡gina) con thumbnails optimizados e implementa scroll infinito.

3. **BFF Services (Django/Python + Django REST Framework)**  
   - **BFF Web** (puerto 8000): Solicita TODOS los productos usando endpoint `/all/` sin paginaciÃ³n.
   - **BFF Mobile** (puerto 8002): Implementa paginaciÃ³n estÃ¡ndar con `page_size=10`.
   
   Cada BFF maneja la lÃ³gica especÃ­fica del cliente: agregaciÃ³n de datos, transformaciÃ³n, y optimizaciones.  
   Los BFFs se comunican con el microservicio de productos para obtener los datos necesarios.

4. **Microservicio Backend (Products Service)**  
   - **Django/Python** con Django REST Framework (puerto 8001)
   - Contiene **84 productos** distribuidos en 6 categorÃ­as: ElectrÃ³nica, Ropa, Hogar, Deportes, Libros, Juguetes
   - Base de datos SQLite con gestiÃ³n de productos, categorÃ­as, imÃ¡genes y stock
   - Endpoints: `/api/products/` (paginado) y `/api/products/all/` (sin paginaciÃ³n)
   - ImÃ¡genes alojadas en Unsplash con URLs de alta resoluciÃ³n y thumbnails

---

## 4. Conceptos clave

| Concepto | DescripciÃ³n |
|-----------|--------------|
| **SeparaciÃ³n de responsabilidades** | Cada BFF se enfoca exclusivamente en las necesidades de su cliente, sin comprometer otros frontends. |
| **AutonomÃ­a de equipos** | Los equipos frontend pueden desarrollar y desplegar sus BFFs independientemente. |
| **OptimizaciÃ³n especÃ­fica** | BFF Web carga todos los productos; BFF Mobile implementa paginaciÃ³n y scroll infinito. |
| **ReducciÃ³n de complejidad** | El backend central no necesita conocer las particularidades de cada frontend. |
| **Mejor rendimiento** | Se eliminan sobrefetching/underfetching al tener APIs perfectamente adaptadas. |

---

## 5. Casos de aplicaciÃ³n reales

| Industria | Escenario de uso | DescripciÃ³n |
|------------|------------------|--------------|
| **E-commerce** | Web vs MÃ³vil | BFF web devuelve 84 productos completos; BFF mÃ³vil devuelve 10 productos por pÃ¡gina con thumbnails. |
| **Streaming (Netflix, Spotify)** | Smart TV vs MÃ³vil | BFF de TV envÃ­a contenido 4K y mÃºltiples episodios; BFF mÃ³vil optimiza para conexiones lentas. |
| **Banking** | App mÃ³vil vs Portal web | BFF mÃ³vil ofrece funciones simplificadas; BFF web incluye reportes detallados. |
| **Social Media** | Web vs App nativa | BFF web carga feeds completos; BFF mÃ³vil implementa infinite scroll optimizado. |

---

## 6. AplicaciÃ³n en el proyecto grupal

En el proyecto de **plataforma e-commerce**, se aplicÃ³ este patrÃ³n para **optimizar la experiencia de compra** segÃºn el dispositivo:

> Se crearon dos BFF services:  
> - **BFF Web** (Django/DRF - puerto 8000): Obtiene todos los productos usando el endpoint `/products/all/` y agrega metadatos como fuente de datos.
> - **BFF Mobile** (Django/DRF - puerto 8002): Implementa paginaciÃ³n con `page=1&page_size=10`, devolviendo respuestas ligeras optimizadas para conexiones mÃ³viles.
>
> Ambos BFFs se comunican con el mismo microservicio **Products Service** (puerto 8001), pero transforman y optimizan las respuestas segÃºn las necesidades del cliente.

---

### Flujo de ejecuciÃ³n

**Para cliente Web (React/Vite):**
1. El usuario accede al catÃ¡logo desde un navegador en `http://localhost:3000`.
2. El frontend React llama a `GET http://localhost:8000/api/products`.
3. El **BFF Web** consulta el endpoint `/api/products/all/` del Products Service.
4. El BFF recibe los 84 productos completos y agrega metadatos:
```json
   {
     "products": [...84 productos...],
     "metadata": {
       "total": 84,
       "page_size": 84,
       "source": "BFF Web - Optimizado para escritorio"
     },
     "featured_banner": {
       "title": "Ofertas de Black Friday",
       "discount": "50% OFF"
     }
   }
```
5. La web muestra todos los productos en un grid de 4 columnas (lg), con imÃ¡genes de 800x600px y datos completos.

**Para cliente MÃ³vil (SwiftUI - iOS):**
1. El usuario accede al catÃ¡logo desde la app mÃ³vil.
2. La app llama a `GET http://192.168.1.49:8002/api/products?page=1`.
3. El **BFF Mobile** consulta `/api/products/?page=1&page_size=10` del Products Service.
4. El BFF devuelve 10 productos con datos optimizados:
```json
   {
     "results": [...10 productos...],
     "page": 1,
     "page_size": 10,
     "source": "BFF Mobile - Optimizado para iOS"
   }
```
5. Al hacer scroll, automÃ¡ticamente carga la pÃ¡gina 2, 3, etc. (scroll infinito).

---

## 7. Arquitectura Dockerizada

Cada componente se ejecuta como un **contenedor independiente**:

| Servicio | Imagen base | Puerto | Rol |
|-----------|--------------|--------|------|
| **web-frontend** | `node:20-alpine` | 3000 | Cliente web React/Vite con Material-UI. |
| **bff-web** | `python:3.11-slim` | 8000 | Backend for Frontend web (Django/DRF). |
| **bff-mobile** | `python:3.11-slim` | 8002 | Backend for Frontend mÃ³vil (Django/DRF). |
| **products-service** | `python:3.11-slim` | 8001 | Microservicio de productos (Django/DRF + SQLite). |

### Estructura del proyecto:
```
Demo/
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ web-frontend/          # React + Vite + MUI
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ package.json
â”‚   â””â”€â”€ src/
â”‚       â”œâ”€â”€ components/
â”‚       â”‚   â”œâ”€â”€ ProductList.tsx
â”‚       â”‚   â”œâ”€â”€ ProductCard.tsx
â”‚       â”‚   â””â”€â”€ Banner.tsx
â”‚       â”œâ”€â”€ services/
â”‚       â”‚   â””â”€â”€ productService.ts
â”‚       â””â”€â”€ types/
â”‚           â””â”€â”€ product.ts
â”œâ”€â”€ bff-web/              # Django BFF Web
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ requirements.txt
â”‚   â””â”€â”€ api/
â”‚       â”œâ”€â”€ views.py      # Llama a /products/all/
â”‚       â””â”€â”€ urls.py
â”œâ”€â”€ bff-mobile/           # Django BFF Mobile
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ requirements.txt
â”‚   â””â”€â”€ api/
â”‚       â”œâ”€â”€ views.py      # Implementa paginaciÃ³n
â”‚       â””â”€â”€ urls.py
â””â”€â”€ products-service/     # Microservicio Products
    â”œâ”€â”€ Dockerfile
    â”œâ”€â”€ requirements.txt
    â”œâ”€â”€ products/
    â”‚   â”œâ”€â”€ models.py     # Product, Category
    â”‚   â”œâ”€â”€ serializers.py
    â”‚   â”œâ”€â”€ views.py      # ViewSet con /all/ endpoint
    â”‚   â””â”€â”€ management/
    â”‚       â””â”€â”€ commands/
    â”‚           â””â”€â”€ create_sample_data.py  # 84 productos
    â””â”€â”€ products_service/
        â””â”€â”€ settings.py   # PAGE_SIZE = 10
```

---

## 8. Diagrama de contenedores (C4 Model â€“ Nivel C2)
```mermaid
C4Container
    title Diagrama de Contenedores - PatrÃ³n Backends for Frontends (E-commerce)

    Person(web_user, "Usuario Web", "Cliente que navega desde navegador desktop")
    Person(mobile_user, "Usuario MÃ³vil", "Cliente que navega desde app iOS (SwiftUI)")

    Container_Boundary(ecommerce, "Plataforma E-commerce") {
        Container(web_frontend, "Web Frontend", "React + Vite + Material-UI", "Interfaz web optimizada: grid 4 columnas, 84 productos")
        Container(mobile_app, "Mobile App", "SwiftUI (iOS)", "AplicaciÃ³n nativa iOS: grid 2 columnas, scroll infinito, paginaciÃ³n")
        
        Container(bff_web, "BFF Web Service", "Django REST Framework", "Puerto 8000: Devuelve TODOS los productos (84) + banner promocional")
        Container(bff_mobile, "BFF Mobile Service", "Django REST Framework", "Puerto 8002: Devuelve 10 productos por pÃ¡gina con thumbnails optimizados")
        
        Container(products_service, "Products Service", "Django REST Framework", "Puerto 8001: GestiÃ³n de 84 productos en 6 categorÃ­as con imÃ¡genes Unsplash")
        
        ContainerDb(sqlite_db, "SQLite Database", "SQLite", "Base de datos con productos, categorÃ­as, stock e imÃ¡genes")
    }

    Rel(web_user, web_frontend, "Navega y visualiza productos\n(http://localhost:3000)")
    Rel(mobile_user, mobile_app, "Navega con scroll infinito")
    
    Rel(web_frontend, bff_web, "Solicita todos los productos\n(GET /api/products)", "HTTP")
    Rel(mobile_app, bff_mobile, "Solicita productos paginados\n(GET /api/products?page=1)", "HTTP")
    
    Rel(bff_web, products_service, "GET /api/products/all/\n(84 productos completos)", "REST API")
    Rel(bff_mobile, products_service, "GET /api/products/?page=X&page_size=10\n(10 productos por peticiÃ³n)", "REST API")
    
    Rel(products_service, sqlite_db, "Lee/Escribe productos\ncon Django ORM")

    UpdateLayoutConfig($c4ShapeInRow="3", $c4BoundaryInRow="1")
```

---

## 9. Ventajas de implementar BFF en el proyecto

âœ… **Experiencia optimizada**: Web carga todos los productos instantÃ¡neamente; mÃ³vil usa scroll infinito eficiente.  
âœ… **Desarrollo independiente**: Equipos web (React) y mÃ³vil (SwiftUI) trabajan sin bloqueos mutuos.  
âœ… **Mejor rendimiento**: Web evita mÃºltiples peticiones; mÃ³vil conserva ancho de banda con paginaciÃ³n.  
âœ… **Escalabilidad selectiva**: Se puede escalar BFF Mobile independientemente si aumenta trÃ¡fico mÃ³vil.  
âœ… **Simplicidad en microservicios**: Products Service permanece simple y agnÃ³stico al tipo de cliente.  
âœ… **ContenedorizaciÃ³n**: Docker Compose permite levantar toda la arquitectura con un solo comando.  
âœ… **OptimizaciÃ³n de imÃ¡genes**: Web usa imÃ¡genes HD (800px); mÃ³vil usa thumbnails (300px).  

---

## 10. Comandos para ejecutar el proyecto
```bash

cd Demo

# Levantar todos los servicios
docker-compose up --build

# Acceder a los servicios
# - Web Frontend: http://localhost:3000
# - BFF Web: http://localhost:8000/api/products
# - BFF Mobile: http://localhost:8002/api/products
# - Products Service: http://localhost:8001/api/products

# Ver logs de un servicio especÃ­fico
docker-compose logs -f bff-web

# Recrear la base de datos con productos
docker-compose exec products-service python manage.py migrate
docker-compose exec products-service python manage.py create_sample_data

# Detener todos los servicios
docker-compose down
```

---

## 11. TecnologÃ­as utilizadas

### Frontend:
- **Web**: React 18 + Vite + TypeScript + Material-UI v5 + Axios
- **Mobile**: SwiftUI + Combine + AsyncImage + iOS 18+

### Backend (BFFs):
- **Framework**: Django 4.2 + Django REST Framework 3.14
- **Python**: 3.11
- **HTTP Client**: requests library

### Microservicio:
- **Framework**: Django 4.2 + Django REST Framework 3.14
- **Base de datos**: SQLite (development)
- **ORM**: Django ORM
- **SerializaciÃ³n**: DRF Serializers

### DevOps:
- **ContainerizaciÃ³n**: Docker + Docker Compose
- **Networking**: Red bridge personalizada (bff-network)
- **Variables de entorno**: PRODUCTS_SERVICE_URL, VITE_API_URL

---

## 12. Video en YouTube

**El siguiente enlace lleva a un video de YouTube que explica el patrÃ³n BFF implementado en este proyecto:**  
- [Arquitectura de Software (PatrÃ³n BFF) - Kohji Onaja](https://youtu.be/eZfe566NTR8)

---

## 13. Conclusiones

La implementaciÃ³n del patrÃ³n **Backends for Frontends** en este proyecto demuestra cÃ³mo una arquitectura bien diseÃ±ada puede optimizar significativamente la experiencia del usuario segÃºn el dispositivo:

1. **SeparaciÃ³n clara de responsabilidades**: Cada BFF se enfoca exclusivamente en su cliente sin comprometer otros.
2. **OptimizaciÃ³n especÃ­fica**: Web obtiene todos los datos en una peticiÃ³n; mÃ³vil usa paginaciÃ³n eficiente.
3. **Escalabilidad**: Los servicios pueden escalar independientemente segÃºn la demanda.
4. **Mantenibilidad**: Cambios en un BFF no afectan al otro ni al microservicio central.
5. **Rendimiento**: Se eliminan roundtrips innecesarios y se optimiza el uso de ancho de banda.

El uso de **Docker** facilita el despliegue y la consistencia entre ambientes, mientras que **Django REST Framework** proporciona una base sÃ³lida y productiva para construir APIs REST robustas.

---

[ğŸ  Home](../../../README.md) | [Siguiente â¡ï¸](../0.7.2/0.7.2.md)
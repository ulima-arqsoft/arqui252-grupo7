> [0. Acerca del Grupo](../../0.md) ‚Ä∫ [0.7. Trabajo Individual (Patrones Cloud)](../0.7.md) ‚Ä∫ [0.7.2. Integrante 2](0.7.2.md)

# 0.7.2. Integrante 2 - Implementaci√≥n del Patr√≥n Cloud: Queue-Based Load Leveling

El patr√≥n **Queue-Based Load Leveling** (nivelaci√≥n de carga basada en colas) es uno de los patrones de resiliencia m√°s utilizados en arquitecturas cloud.  
Su prop√≥sito principal es **desacoplar** los componentes del sistema que producen cargas variables (productores) de los que las procesan (consumidores), asegurando una ejecuci√≥n **estable y escalable**, incluso ante picos de demanda.

---

## 2. Problema

En una arquitectura tradicional de microservicios, el backend puede **saturarse** cuando m√∫ltiples clientes realizan solicitudes simult√°neamente.  
Esto genera:

- Sobrecarga de CPU o base de datos.  
- Errores 500 por timeouts.  
- Lentitud en el procesamiento de peticiones cr√≠ticas (como pagos o registros).

En el caso de un **e-commerce**, las operaciones de creaci√≥n de pedidos o pagos son costosas y sensibles.  
Si todos los usuarios env√≠an solicitudes de compra al mismo tiempo (por ejemplo, en Black Friday), el backend colapsa.

---

## 3. Soluci√≥n: Patr√≥n Queue-Based Load Leveling

El patr√≥n propone introducir una **cola intermedia** entre el productor (API de entrada) y el consumidor (servicio que procesa).

### Estructura b√°sica:

1. **Productor (FastAPI)**  
   Recibe solicitudes HTTP y **coloca los mensajes en una cola** (Redis).  
   Responde inmediatamente al usuario con un c√≥digo de √©xito, sin bloquear la operaci√≥n.

2. **Cola (Redis / RabbitMQ / Azure Queue)**  
   Almacena temporalmente las tareas pendientes.  
   Sirve como **buffer** entre productor y consumidor.

3. **Consumidor (Worker en TypeScript)**  
   Extrae los mensajes de la cola y los procesa de manera **as√≠ncrona** y **controlada**.  
   Puede escalar horizontalmente para manejar m√°s carga.

---

## 4. Conceptos clave

| Concepto | Descripci√≥n |
|-----------|--------------|
| **Desacoplamiento** | El productor no depende de la velocidad o disponibilidad del consumidor. |
| **Elasticidad** | Pueden agregarse m√∫ltiples consumidores (workers) seg√∫n la carga. |
| **Resiliencia** | La cola act√∫a como amortiguador, evitando que se pierdan mensajes ante fallos temporales. |
| **Persistencia temporal** | Redis o RabbitMQ garantizan que los mensajes no se pierdan si el consumidor falla moment√°neamente. |
| **Escalabilidad** | Permite manejar picos de tr√°fico sin aumentar la carga del API principal. |

---

## 5. Casos de aplicaci√≥n reales

| Industria | Escenario de uso | Descripci√≥n |
|------------|------------------|--------------|
| **E-commerce** | Procesamiento de pedidos | Cada compra se encola para ser procesada por un worker sin bloquear al cliente. |
| **Finanzas** | Validaci√≥n de transacciones | Un API recibe pagos y los valida en segundo plano. |
| **IoT** | Recepci√≥n de datos masivos | Los dispositivos publican datos que luego se procesan por lotes. |
| **Medios digitales** | Procesamiento de im√°genes o videos | Cada carga se encola y se transforma de forma as√≠ncrona. |

---

## 6. Aplicaci√≥n en el proyecto grupal

En el proyecto de **plataforma e-commerce**, se aplic√≥ este patr√≥n en el **m√≥dulo de pedidos**:

> Al recibir un nuevo pedido, el backend desarrollado en **FastAPI** lo coloca en una **cola Redis**.  
> Un **worker en TypeScript** consume los mensajes, simulando el procesamiento del pago y la actualizaci√≥n del stock.  
> La base de datos fue **simulada dentro del backend** para concentrar el enfoque en el patr√≥n, evitando dependencias externas.

---

### Flujo de ejecuci√≥n

1. El usuario realiza una compra (`POST /order`).  
2. El backend (FastAPI) la env√≠a a una cola `orders_queue` en Redis.  
3. El API responde `202 Accepted` inmediatamente.  
4. El worker en TypeScript lee la cola y procesa los pedidos.  
5. Se registra la ejecuci√≥n en consola (simulando inserci√≥n en DB).

---

## 7. Arquitectura Dockerizada

Cada componente se ejecuta como un **contenedor independiente**:

| Servicio | Imagen base | Rol |
|-----------|--------------|------|
| **api** | `python:3.11-slim` | Productor ‚Äî expone endpoints REST (FastAPI). |
| **worker** | `node:20` | Consumidor ‚Äî procesa pedidos de la cola. |
| **redis** | `redis:7` | Sistema de mensajer√≠a intermedio. |

---

### 8. Diagrama de contenedores (C4 Model ‚Äì Nivel C2)

```mermaid
C4Container
    title Diagrama de Contenedores - Patr√≥n Queue-Based Load Leveling (E-commerce)

    Person(customer, "Cliente", "Usuario que realiza compras desde la web o app m√≥vil")

    Container_Boundary(ecommerce, "Plataforma E-commerce") {
        Container(api, "Backend API", "Python / FastAPI", "Recibe solicitudes de compra y publica los pedidos en la cola Redis.")
        ContainerDb(redis, "Redis Queue", "Redis", "Almacena temporalmente los pedidos pendientes de ser procesados.")
        Container(worker, "Worker Service", "TypeScript / Node.js", "Consume la cola de pedidos y los procesa de manera as√≠ncrona.")
    }

    Rel(customer, api, "Realiza solicitudes de compra\n(POST /order)")
    Rel(api, redis, "Publica los pedidos\n(Protocolo Redis)")
    Rel(redis, worker, "Entrega mensajes para procesar\n(Protocolo Redis)")
    Rel(worker, api, "Actualiza el estado del pedido\n(API interna o webhook)")

```

---

[‚¨ÖÔ∏è Anterior](../0.7.1/0.7.1.md) | [üè† Home](../../../README.md) | [Siguiente ‚û°Ô∏è](../0.7.3/0.7.3.md)
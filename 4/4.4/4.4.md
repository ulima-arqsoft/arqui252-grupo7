> [4. Decisiones Iniciales de Arquitectura](../4.md) ‚Ä∫ [4.4. M√≥dulo 4 / Integrante 4](4.4.md)

# 4.1. M√≥dulo 4 - Visualizaci√≥n de Productos - Hideki Sotero

## 1) Decisiones de Frontend (Kotlin para Android / Swift para iOS)

### 1.1 Patr√≥n de arquitectura de presentaci√≥n
- **Decisi√≥n:** **MVVM** con unidireccionalidad de datos.
  - **Android:** **Kotlin** + **Jetpack Compose** para UI, `ViewModel`, `LiveData`, `StateFlow` para manejar el estado de la aplicaci√≥n.
  - **iOS:** **Swift** + **SwiftUI**, `ObservableObject` / `@StateObject`, Combine.
- **Justificaci√≥n:** Mejora la testabilidad, desacopla la UI de la l√≥gica y facilita el mantenimiento en ambas plataformas m√≥viles.
- **Implicaciones:** La interfaz ser√° reactiva y responder√° de manera eficiente a las interacciones del usuario tanto en **Android** como en **iOS**.

### 1.2 Optimizaci√≥n de rendimiento
- **Decisi√≥n:** Implementaci√≥n de **lazy loading** y **paginaci√≥n infinita**.
- **Justificaci√≥n:** Evita la carga de todos los productos al mismo tiempo, mejorando la experiencia del usuario en t√©rminos de velocidad y eficiencia de recursos.
- **Implicaciones:** Mejora la carga y hace que la visualizaci√≥n de grandes cat√°logos de productos sea eficiente, garantizando una experiencia fluida en dispositivos m√≥viles.

---

## 2) Decisiones de Backend (.NET API C# con PostgreSQL)

### 2.1 Modelo de Datos
- **Decisi√≥n:** El backend utilizar√° una **base de datos relacional PostgreSQL** para almacenar los productos, y se combinar√° con **caching en memoria (Redis)** para mejorar la rapidez de las consultas y la carga de productos populares.
- **Justificaci√≥n:** El modelo de datos de productos, incluyendo variantes de tallas y colores, requiere un esquema estructurado, lo que hace que una base de datos relacional sea m√°s adecuada para este caso en lugar de una base de datos NoSQL.
- **Implicaciones:** Aunque una base de datos **NoSQL clave-valor** podr√≠a ser adecuada para almacenar estados de sesi√≥n o datos con alta frecuencia de lectura y baja complejidad, no es la mejor opci√≥n para gestionar los datos estructurados de productos que requieren relaciones entre entidades (productos, variantes, precios). **PostgreSQL** es ideal para consultas complejas y un modelo de datos estructurado.

### 2.2 Cach√© y Rendimiento
- **Decisi√≥n:** Se utilizar√° **Redis** como sistema de cach√© de lectura para los productos m√°s populares y para mejorar el rendimiento de las consultas m√°s frecuentes, como las b√∫squedas y los filtros.
- **Justificaci√≥n:** **Redis**, como base de datos **NoSQL clave-valor**, es ideal para almacenar resultados de consultas que no requieren consistencia inmediata o que se consultan frecuentemente, como los productos m√°s visitados o las b√∫squedas recientes.
- **Implicaciones:** **Redis** permitir√° acceder a los datos de manera r√°pida y eficiente, pero para evitar incoherencias, la informaci√≥n se sincronizar√° regularmente con la base de datos relacional **PostgreSQL**.

### 2.3 Sincronizaci√≥n de Productos con Backend
- **Decisi√≥n:** **NoSQL clave-valor** (por ejemplo, **Redis**) no se usar√° como base de datos principal para los productos debido a la necesidad de relaciones entre productos, variantes y precios. **PostgreSQL** se utilizar√° como la base de datos principal para almacenar toda la informaci√≥n estructurada del cat√°logo de productos.
- **Justificaci√≥n:** Una base de datos **NoSQL clave-valor**, como **Redis**, podr√≠a ser √∫til para casos espec√≠ficos como la cach√© de consultas frecuentes, pero para almacenar las relaciones entre productos, tallas, colores, precios y stocks, **PostgreSQL** es una mejor opci√≥n debido a su robustez y capacidad para manejar relaciones complejas.
- **Implicaciones:** Usar **PostgreSQL** para los productos asegura que todas las relaciones entre productos, precios y variantes sean consistentes, mientras que **Redis** optimiza el rendimiento en la entrega de productos m√°s solicitados.

---

## 3) Decisiones de Datos (PostgreSQL)

### 3.1 Modelo Relacional vs. NoSQL
- **Decisi√≥n:** El modelo de datos de productos se almacenar√° en **PostgreSQL**, debido a que requiere relaciones complejas entre productos, categor√≠as, variantes y precios, que son m√°s f√°cilmente manejadas en un sistema relacional.
- **Justificaci√≥n:** Aunque una base de datos **NoSQL clave-valor** podr√≠a ser √∫til para ciertos casos de uso (como almacenamiento de sesi√≥n, preferencias del usuario o caching de datos), no es ideal para manejar productos con muchas relaciones (por ejemplo, productos con m√∫ltiples variantes, categor√≠as, precios, etc.).
- **Implicaciones:** **PostgreSQL** manejar√° todas las relaciones de manera eficiente, mientras que **Redis** se usar√° para almacenar en cach√© informaci√≥n no cr√≠tica o de lectura frecuente, lo que reduce la carga en la base de datos principal.

### 3.2 Uso de Redis como Caching
- **Decisi√≥n:** **Redis** se utilizar√° para almacenar informaci√≥n en cach√©, como los resultados de b√∫squedas populares, productos m√°s vendidos y recomendaciones.
- **Justificaci√≥n:** **Redis** es un sistema **NoSQL clave-valor** extremadamente r√°pido y eficiente para almacenar datos de acceso frecuente, como los productos m√°s consultados o m√°s populares, mejorando el rendimiento sin comprometer la consistencia de los datos en **PostgreSQL**.
- **Implicaciones:** Esto permitir√° que los datos sean servidos r√°pidamente desde la cach√©, reduciendo la carga en la base de datos principal y mejorando la experiencia del usuario.

---

[‚¨ÖÔ∏è Anterior](../4.3/4.3.md) | [üè† Home](../../README.md) | [Siguiente ‚û°Ô∏è](../4.5/4.5.md)
> [4. Decisiones Iniciales de Arquitectura](../4.md) › [4.1. Módulo 1 / Integrante 1](4.1.md)

# 4.1. Módulo 1 / Integrante 1 — Gestión de Carrito de Compras

Esta sección documenta las **decisiones arquitectónicas iniciales** del módulo de **Gestión de Carrito de Compras** para el Ecommerce de Ropa.  
Cubre **frontend (Android/iOS)** y **backend (.NET API C# con PostgreSQL)**, alineadas a los escenarios priorizados (rendimiento, disponibilidad, seguridad, mantenibilidad y escalabilidad).

---

## 1) Alcance del módulo
- **Responsabilidad:** persistir y orquestar el carrito (items, cantidades, cupones), calcular totales (subtotal, impuestos, envío, descuentos) y exponer operaciones de *checkout* hacia Pedidos y Pagos.
- **Fuera de alcance:** cobro con pasarela (módulo Pagos), *fulfillment* y trazabilidad logística (módulo Pedidos/Inventario).

---

## 2) Decisiones de Frontend (Android / iOS)

### 2.1 Patrón de arquitectura de presentación
- **Decisión:** **MVVM** con unidireccionalidad de datos.
  - **Android:** Kotlin + Jetpack **Compose**, `ViewModel`, `StateFlow`.
  - **iOS:** Swift + **SwiftUI**, `ObservableObject` / `@StateObject`, Combine.
- **Justificación:** facilita testabilidad, desacopla UI de lógica y reduce *boilerplate*.  
- **Implicaciones:** estados y efectos bien definidos → menor riesgo de estados incoherentes del carrito.

### 2.2 Gestión de estado del carrito
- **Decisión:** **Single Source of Truth** local + sincronización con servidor.
  - **Android:** `DataStore` (preferencias livianas) + cache en memoria.
  - **iOS:** `UserDefaults`/ligero cache + memoria.
- **Justificación:** respuesta inmediata en UI y resiliencia a pérdidas de red.  
- **Implicaciones:** se implementa **merge** determinístico con el backend (ver 3.5).

### 2.3 Modo offline y reconexión
- **Decisión:** **Cola local de acciones** (add/remove/update) con **reintentos** y **backoff exponencial**.
- **Justificación:** el usuario puede editar el carrito sin conectividad; cambios se sincronizan al volver la red.  
- **Implicaciones:** requerimos **idempotency keys** por operación (ver 3.6).

### 2.4 Cálculo de totales en cliente
- **Decisión:** cálculo **optimista** en cliente (reglas cacheadas) + **revalidación** en servidor.
- **Justificación:** UX fluida; el backend es la **autoridad** para evitar fraudes/errores.  
- **Implicaciones:** mostrar *badges* “estimado/confirmado” y reconciliar en `onCheckout()`.

### 2.5 Navegación y accesibilidad
- **Decisión:** flujos guiados **Carrito → Dirección → Pago → Confirmación** con validaciones progresivas y soporte **WCAG** básico (tamaños, contraste, *VoiceOver/TalkBack*).
- **Justificación:** reduce abandono de carrito y cumple el escenario de accesibilidad.

---

## 3) Decisiones de Backend (.NET API C#)

### 3.1 Estilo de API y proyecto
- **Decisión:** **REST** sobre **ASP.NET Core Minimal APIs**, *Clean Architecture* (capas: API, Application, Domain, Infrastructure).
- **Justificación:** bajo *overhead*, fácil versionado y pruebas; separación de preocupaciones.  
- **Implicaciones:** controladores/handlers delgados; reglas en **Domain/Application**.

### 3.2 Modelo de datos de carrito
- **Decisión:** **Carrito servidor** (por `user_id` o `guest_id`) con:
  - `carts(id, user_id|guest_id, currency, updated_at)`
  - `cart_items(id, cart_id, product_id, sku, qty, unit_price_snapshot, metadata jsonb)`
  - `cart_discounts(cart_id, code, amount, type)`
- **Justificación:** coherencia entre dispositivos, soporte a invitado y auditoría.  
- **Implicaciones:** se requiere **merge** de carrito invitado → usuario al loguear.

### 3.3 Consistencia y concurrencia
- **Decisión:** **Optimistic Concurrency** con `row_version` y **unique constraints** (`cart_id, sku`).
- **Justificación:** evita bloqueos; detecta *write-write conflicts* en picos.  
- **Implicaciones:** si hay conflicto, el API retorna `409` con payload de reconciliación.

### 3.4 Cálculo de totales
- **Decisión:** **CQRS light**: comandos actualizan *source of truth*; **proyección de lectura** para totales materializados (`cart_totals_view`).
- **Justificación:** respuestas rápidas (p95 < 150ms) y lógica de precios centralizada.  
- **Implicaciones:** *refresh* de proyección por *trigger* o *domain event*.

### 3.5 Estrategia de “merge” de carritos
- **Decisión:** **Merge “sumarizante con preferencia servidor”**:
  1) Normalizar SKUs, 2) consolidar cantidades, 3) remover ítems no vigentes, 4) recalcular totales/beneficios.
- **Justificación:** experiencia continua entre invitado y autenticado.  
- **Implicaciones:** endpoint `POST /carts/merge` con reporte de diferencias.

### 3.6 Idempotencia y reintentos
- **Decisión:** **Idempotency-Key** (header) por operación mutante y **Transactional Outbox** para eventos (→ Pedidos, Inventario).
- **Justificación:** evita duplicados en reintentos y asegura entrega eventual de eventos.  
- **Implicaciones:** tabla `outbox` + procesador en segundo plano (Hosted Service).

### 3.7 Seguridad y autenticación
- **Decisión:** **JWT** (usuarios) + **Guest Token** firmado para carritos anónimos; **RBAC** mínimo.
- **Justificación:** protege APIs y permite carrito sin registro.  
- **Implicaciones:** renovar guest token al convertir en usuario y hacer **cart merge** (3.5).

### 3.8 Validación y protección
- **Decisión:** **Rate limiting** por IP/usuario, **input validation** (FluentValidation), **CSRF** no aplica a APIs puras; **CORS** restringido.
- **Justificación:** reduce abuso y vectores comunes.  
- **Implicaciones:** cuotas configurables por entorno.

### 3.9 Resiliencia e integración
- **Decisión:** **Polly** (retry + circuit breaker + timeout) en llamadas a Precios/Inventario/Envíos.
- **Justificación:** aislamiento de fallas y picos de latencia.  
- **Implicaciones:** telemetría de estados del *breaker* y métricas de reintentos.

### 3.10 Observabilidad
- **Decisión:** **OpenTelemetry** (trazas, métricas, logs) + **correlación** por `X-Request-Id` y `user_id`.
- **Justificación:** diagnóstico de p95/p99, *error budgets* y embudos de conversión.  
- **Implicaciones:** tableros para Carrito: *add-to-cart rate*, *update latency*, *merge success*, *abandon rate*.

---

## 4) Decisiones de Datos (PostgreSQL)

### 4.1 Esquema y tipos
- **Decisión:** uso de **`jsonb`** para metadatos de variantes, **índices compuestos** (`cart_id, sku`), **índices parciales** para `active=true`.
- **Justificación:** flexibilidad de catálogo y consultas rápidas.  
- **Implicaciones:** políticas de limpieza de metadatos huérfanos.

### 4.2 Integridad y transacciones
- **Decisión:** **ACID** con **READ COMMITTED**, *upserts* (`ON CONFLICT`) y **check constraints** en cantidades y monedas.
- **Justificación:** integridad y rendimiento adecuado.  
- **Implicaciones:** transacciones cortas; lógica compleja en capa de aplicación.

### 4.3 Rendimiento y mantenimiento
- **Decisión:** **Auto-vacuum** afinado, **connection pooling** (Npgsql + pgBouncer), **caché** de lectura (Redis) para reglas de precios y cupones.
- **Justificación:** estabilidad en picos y menor presión de I/O.  
- **Implicaciones:** invalidación de caché por *event* de cambio de precio.

---


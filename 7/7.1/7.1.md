> [7. Estructura Inicial de Código](../7.md) › [7.1. Catálogo de Aplicaciones](7.1.md)

# 7.1. Catálogo de Aplicaciones

### 7.1.1. iOS (Swift) — Clean Architecture

La aplicación móvil para iOS está desarrollada en **Swift**, utilizando **SwiftUI** y **Combine**, bajo el patrón **Clean Architecture**.  
Este enfoque permite mantener un bajo acoplamiento entre capas, independencia de frameworks y alta testabilidad, siguiendo la dirección de dependencias **Presentation → Domain → Data**.

**Aplicación** | **Contenedor** | **Tecnología FE** | **Tecnología BE** | **BD (local)** | **Repositorio/Carpeta**
---|---|---|---|---|---
App iOS cliente | Mobile (iOS) | SwiftUI, Combine, MVVM | .NET API C# (REST) | UserDefaults / CoreData | `https://github.com/ulima-arqsoft/arqui252-grupo7-mobile-ios/tree/develop`

> Estructura general del proyecto en Xcode:  
> ![swift_loop_app](images/swift_loop_app.png)

---

#### Estructura de carpetas

- `Loop/App/Data/` — fuentes de datos, implementación de repositorios.  
- `Loop/App/Data/Datasources/` — acceso remoto (API REST) o local (UserDefaults, CoreData).  
- `Loop/App/Data/Repositories/` — implementación concreta de interfaces del dominio.  

- `Loop/App/Domain/` — entidades, errores y casos de uso del negocio (agnósticos de framework).  
- `Loop/App/Domain/Models/` — modelos de dominio como `Cart`, `Product`, `User`.  
- `Loop/App/Domain/UseCases/` — casos de uso principales: agregar producto, eliminar item, sincronizar carrito.  

- `Loop/App/Infrastructure/` — capa técnica: red, persistencia y servicios auxiliares.  
- `Loop/App/Infrastructure/Networking/` — cliente HTTP con `URLSession`, autenticación JWT, manejo de errores.  
- `Loop/App/Infrastructure/UserDefaults/` — almacenamiento ligero de preferencias y carrito invitado.  

- `Loop/App/Presentation/` — capa de presentación (UI + ViewModels).  
- `Loop/App/Presentation/Scenes/` — vistas y pantallas (SwiftUI) organizadas por módulo:  
  - `Cart/` — gestión del carrito (RF-GC-01, RF-GC-02).  
  - `Explore/` — catálogo de productos.  
  - `Product/` — detalle de producto.  
  - `Profile/` — perfil e historial de compras (RF-GC-09).  
  - `TabView/` — navegación principal.  
- `Loop/App/Presentation/Shared/` — componentes visuales reutilizables (botones, headers, estilos).

- `Loop/App/SupportingFiles/` — recursos, assets, configuraciones.  
- `Loop/App/Info/` — metadatos del proyecto (`Info.plist`).  
- `AppDelegate.swift` / `LoopApp.swift` — punto de entrada y configuración inicial del entorno.

---

#### Decisiones técnicas principales

- **Arquitectura:** Clean Architecture + MVVM (separación estricta de UI, dominio y datos).  
- **Estado global:** `@StateObject` + `ObservableObject` para reactividad y sincronización con backend.  
- **Networking:** `URLSession` con `async/await`, encabezados `Authorization` (JWT) y `X-Request-Id`.  
- **Persistencia:** `UserDefaults` para carrito local; `CoreData` opcional para cachear catálogo y precios.  
- **Casos de uso:** definidos en *Domain*, independientes de frameworks, probados con `XCTest`.  
- **Accesibilidad:** compatibilidad con *VoiceOver* y *Dynamic Type*.  
- **Integración backend:** consumo de endpoints `/carts`, `/checkout`, `/orders` del backend .NET + PostgreSQL.

---

#### Ejemplo de correspondencia conceptual

| Capa | Función | Ejemplo |
|------|----------|----------|
| **Data** | Fuente de datos (repositorios, API, almacenamiento) | `CartRepository.swift`, `CartRemoteDataSource.swift` |
| **Domain** | Lógica de negocio, entidades y casos de uso | `AddProductUseCase.swift`, `Cart.swift` |
| **Infrastructure** | Servicios de soporte técnico | `NetworkClient.swift`, `UserDefaultsService.swift` |
| **Presentation** | UI y ViewModels | `CartView.swift`, `CartViewModel.swift` |

---

> En conjunto, esta arquitectura garantiza independencia del framework, soporte offline-first y sincronización confiable del carrito, alineada con los requisitos funcionales y no funcionales del *Ecommerce de Ropa*.

---
### 7.1.2. Backend (.NET) — Clean Architecture

El backend del sistema **Loop** está desarrollado en **.NET 8 (C#)**, aplicando los principios de **Clean Architecture** y una organización modular orientada a capas, garantizando separación de responsabilidades, mantenibilidad y testabilidad.  

La estructura general sigue el flujo de dependencias:  
**Controllers → Services → Data/Models → Database (PostgreSQL)**.

**Aplicación** | **Contenedor** | **Tecnología FE** | **Tecnología BE** | **Base de Datos** | **Repositorio/Carpeta**
---|---|---|---|---|---
API REST .NET | Backend | — | ASP.NET Core 8 (C#), EF Core | PostgreSQL | `/Loop`

> Estructura general del proyecto en Visual Studio Code:  
> ![dotnet_loop_app](images/dotnet_loop_app.png)

---

#### Estructura de carpetas

- `Controllers/` — controladores principales de la API.  
  Contienen los endpoints REST que exponen la lógica del dominio.  
  Ejemplo: `UserController.cs`, `ProductController.cs`.

- `Data/` — capa de acceso a datos.  
  Define el contexto de base de datos (`DbContext`) y configuraciones de entidades.  
  Ejemplo: `AppDbContext.cs`.

- `Models/` — modelos de dominio y entidades persistentes.  
  Representan tablas de la base de datos y estructuras de negocio.  
  Ejemplo: `User.cs`, `Product.cs`.

- `DTOs/` — objetos de transferencia de datos.  
  Facilitan la comunicación entre la capa de presentación y los modelos.  
  Ejemplo: `UserDTO.cs`, `ProductDTO.cs`.

- `Services/` — capa de lógica de negocio y casos de uso.  
  Implementa las operaciones principales del dominio (creación, filtrado, validación, subida de archivos).  
  Ejemplo: `EmailService.cs`.

- `Documentation/` — especificaciones y descripciones de la base de datos.  
  Ejemplo: `structure.sql`, `data.sql`.

- `logs/` — registro de eventos, errores y auditorías del sistema.

- `Properties/`, `obj/` — archivos de configuración y metadatos del proyecto.

- `appsettings.json` / `appsettings.Development.json` — configuración de entorno (cadena de conexión, JWT, etc.).

- `.env` — variables de entorno sensibles (claves secretas, rutas de conexión).

- `Dockerfile` / `docker-compose.yml` — configuración de despliegue en contenedores Docker.  
  Define la imagen base .NET, el servicio PostgreSQL y la red de la aplicación.

- `run_docker.py` — script auxiliar en Python para automatizar la construcción y ejecución del contenedor.

- `Program.cs` — punto de entrada principal de la aplicación.  
  Configura los servicios, dependencias y middlewares (autenticación, CORS, Swagger, EF Core).

- `Loop.csproj` — archivo de configuración del proyecto .NET, dependencias y metadatos.

---

#### Decisiones técnicas principales

- **Arquitectura:** Clean Architecture + Repository-Service Pattern.  
- **Framework:** ASP.NET Core 8 con Entity Framework Core.  
- **Persistencia:** PostgreSQL, con migraciones automáticas mediante `dotnet ef`.  
- **Inyección de dependencias:** nativa de .NET (`IServiceCollection`).  
- **Autenticación y seguridad:** JWT Bearer + validación de roles.  
- **Documentación:** Swagger UI / OpenAPI.  
- **Despliegue:** Docker + `docker-compose` con servicio de base de datos y red interna.  
- **Manejo de logs:** Integración con `ILogger` y almacenamiento en `logs/`.  
- **Configuración dinámica:** `appsettings.*.json` y variables `.env`.  

---

#### Ejemplo de correspondencia conceptual

| Capa | Función | Ejemplo |
|------|----------|----------|
| **Controllers** | Exposición de endpoints REST | `UserController.cs`, ProductController.cs` |
| **Services** | Lógica de negocio y validaciones | `EmailService.cs` |
| **Data** | Contexto y acceso a base de datos | `AppDbContext.cs` |
| **Models** | Entidades del dominio | `User.cs`, `Product.cs` |
| **DTOs** | Transferencia de datos entre capas | `UserDTO.cs`, `ProductDTO.cs` |

---

### 7.1.3. Android (Kotlin) — Clean Architecture

La aplicación móvil para **Android** está desarrollada en **Kotlin**, utilizando **Jetpack Compose** para la interfaz de usuario y principios de **Clean Architecture**, siguiendo la dirección de dependencias **Presentation → Domain → Data**.  
Esta estructura modular garantiza bajo acoplamiento, fácil testeo e independencia de frameworks, alineada con las buenas prácticas promovidas por **Phillip Lackner**.

**Aplicación** | **Contenedor** | **Tecnología FE** | **Tecnología BE** | **BD (local)** | **Repositorio/Carpeta**
---|---|---|---|---|---
App Android cliente | Mobile (Android) | Jetpack Compose, MVVM, Hilt | .NET API C# (REST) | Room / DataStore | `/android/app`

> Estructura general del proyecto en Android Studio:  
> ![android_loop_app](images/file_structure_android_app.png)

---

#### Estructura de carpetas

- `app/src/main/java/arqsoft/ulima/loop_app/`

  - **`core/`** — componentes compartidos y utilitarios del núcleo de la aplicación.
    - `data.sessionStorage/` — almacenamiento local de sesión (tokens, usuario autenticado).
    - `domain/` — modelos y lógica de negocio compartida.
    - `presentation/` — componentes comunes de UI (`components`, `designsystem`).

  - **`di/`** — módulos de **Hilt** para la inyección de dependencias (repositorios, casos de uso, clientes HTTP).

  - **`features/`** — contiene los distintos módulos funcionales de la app (por ejemplo: *auth*, *catalog*, *cart*, *profile*).  
    Cada *feature* sigue el patrón **Clean Architecture** con sus propias capas:
    - `data/` — *data sources*, repositorios e implementación de interfaces del dominio.
    - `domain/` — entidades y casos de uso específicos del módulo.
    - `presentation/` — pantallas, *ViewModels* y estados de UI (Compose).

  - **`main/`** — punto de entrada de la aplicación (navegación principal, configuración inicial de Compose).

  - **`util.networking/`** — cliente HTTP y utilidades de red.
    - `connectionManager/` — gestión de conectividad y disponibilidad de red.
    - `HttpClientExt.kt`, `HttpClientFactory.kt` — configuración base del cliente Ktor (timeouts, headers, logging).

- `res/` — recursos gráficos, layouts XML (si aplica), cadenas de texto, íconos y temas.

---

#### Decisiones técnicas principales

- **Arquitectura:** Clean Architecture + MVVM + Hilt (inyección de dependencias).  
- **UI:** Jetpack Compose con *State Hoisting* y componentes reutilizables (`designsystem`).  
- **Estado global:** `ViewModel` + `StateFlow` / `MutableStateFlow` para la reactividad.  
- **Networking:** Cliente **Ktor** con interceptores para autenticación y logging.  
- **Persistencia:** **Room** (bases de datos locales) y **DataStore** (preferencias ligeras).  
- **Inyección de dependencias:** **Hilt** (módulos definidos en `/di`).  
- **Testing:** *Unit Tests* en `test/` y *instrumentation tests* en `androidTest/`.  
- **Manejo de errores:** `sealed classes` en el dominio para resultados seguros (`Result<T>` o `Resource<T>`).  
- **Navegación:** `NavHost` de Compose con rutas definidas por feature.

---

#### Ejemplo de correspondencia conceptual

| Capa | Función | Ejemplo |
|------|----------|----------|
| **Data** | Acceso a fuentes de datos (API REST, Room, DataStore) | `AuthRepositoryImpl.kt`, `CatalogRemoteDataSource.kt` |
| **Domain** | Lógica de negocio, entidades y casos de uso | `LoginUseCase.kt`, `Product.kt` |
| **Presentation** | Interfaz de usuario y estado | `LoginScreen.kt`, `CatalogViewModel.kt` |
| **Core / Util** | Componentes comunes y servicios técnicos | `HttpClientFactory.kt`, `SessionStorage.kt` |

---
# 7.1.4. Frontend Web (React + Vite + MUI)

El **Frontend Web** del sistema **Ecommerce de Ropa** está desarrollado en **React** con **TypeScript**, utilizando **Vite** como herramienta de construcción y **Material UI (MUI)** para los componentes de interfaz.  
Esta aplicación representa el **Panel del Vendedor / Administrador**, donde se visualizan métricas del negocio, pedidos, inventario, clientes y configuración general.

**Aplicación** | **Contenedor** | **Tecnología FE** | **Tecnología BE** | **Repositorio/Carpeta**
---|---|---|---|---
Panel Web de Vendedor/Admin | Front_Dashboard | React, TypeScript, Vite, MUI | API Node.js (REST) | `https://github.com/ulima-arqsoft/arqui252-grupo7/tree/main/frontend`

> Estructura general del proyecto en VS Code:  
> ![front_web](images/front_web.png)

---

### Estructura de carpetas

- `public/` — Contiene los recursos estáticos globales (íconos, logos, manifest).  
- `src/` — Carpeta principal que agrupa todo el código fuente de la aplicación.
  - `_mock/` — Datos de prueba y mocks de productos, pedidos o clientes usados para desarrollo local.
  - `components/` — Componentes reutilizables de interfaz (botones, tarjetas, tablas, gráficas).
  - `layouts/` — Plantillas base y diseño general del dashboard (sidebar, navbar, footer).
  - `pages/` — Páginas principales del sistema (Dashboard, Inventario, Pedidos, Clientes, Configuración).
  - `routes/` — Definición de rutas con React Router (v6) y control de navegación según el rol del usuario.
  - `sections/` — Agrupaciones lógicas de vistas y widgets:
    - `overview/` — Sección principal del dashboard, incluye gráficos y métricas del negocio.
    - `product/` — Módulo de productos e inventario:
      - `view/` — Vistas individuales y widgets de interacción con productos.  
        - `product-cart-widget.tsx` — Widget interactivo del carrito de compras.  
        - `product-item.tsx` — Representación visual de un producto individual.
  - `theme/` — Configuración del tema global (paleta de colores, tipografías, estilos MUI).
  - `utils/` — Funciones auxiliares y constantes globales (formatos, validaciones, fechas).
  - `app.tsx` — Punto de entrada de la aplicación React (estructura principal y provider de contexto).
  - `config-global.ts` — Configuración global del proyecto (endpoints, colores, layouts).
  - `global.css` — Estilos base aplicados a todo el proyecto.
  - `main.tsx` — Render principal del árbol React.
  - `vite-env.d.ts` — Tipos personalizados para el entorno Vite + TypeScript.

- Archivos raíz:
  - `.eslintrc.mjs` / `.prettierrc` — Configuración de linting y formato del código.  
  - `package.json` / `package-lock.json` — Dependencias del proyecto.  
  - `vite.config.ts` — Configuración del entorno Vite y plugins.  
  - `index.html` — Documento raíz HTML inyectado por Vite.  
  - `tsconfig.json` — Configuración de TypeScript.  

---

### Decisiones técnicas principales

- **Arquitectura:** Basada en componentes funcionales + hooks, organizada por módulos de negocio (`sections/`).  
- **Librerías UI:** MUI (Material UI) con sistema de diseño adaptativo y tema personalizado.  
- **Routing:** Implementado con **React Router v6**, soportando navegación anidada y rutas protegidas.  
- **Gestión de estado:** Estado local con hooks (`useState`, `useEffect`) y contexto global con `React.Context`.  
- **Datos simulados:** `_mock/` utilizado para pruebas sin conexión al backend.  
- **Interfaz responsiva:** Layout adaptable a escritorio, tablet y móvil con breakpoints de MUI.  
- **Optimización:** Vite para builds rápidos, tree-shaking y carga modular.  
- **Validación de formularios:** Controlada mediante MUI + validaciones personalizadas.  
- **Conexión al backend:** Axios para comunicación con la API REST en Node.js.  
- **Control de código:** Estandarizado con ESLint, Prettier y Husky (pre-commit hooks).  
- **Pruebas:** Pruebas unitarias con Jest y React Testing Library.  

---

### Correspondencia conceptual

| Capa | Función | Ejemplo |
|------|----------|----------|
| **Componentes** | Elementos reutilizables y modulares de UI | `CardStats.tsx`, `AlertDialog.tsx`, `ChartLine.tsx` |
| **Layouts** | Plantillas principales del panel | `DashboardLayout.tsx`, `Sidebar.tsx`, `Navbar.tsx` |
| **Pages** | Páginas de navegación con rutas principales | `DashboardPage.tsx`, `OrdersPage.tsx` |
| **Sections** | Agrupaciones funcionales por dominio | `overview/index.tsx`, `product/view/product-item.tsx` |
| **Theme** | Configuración visual global | `theme/palette.ts`, `theme/typography.ts` |
| **Utils** | Funciones y constantes comunes | `utils/formatDate.ts`, `utils/validateInput.ts` |

---

### Beneficios de la estructura

- **Escalabilidad:** Estructura modular fácil de ampliar con nuevas secciones o componentes.  
- **Mantenibilidad:** Separación clara de responsabilidades y código reutilizable.  
- **Consistencia visual:** Implementación centralizada del tema y diseño.  
- **Productividad:** Integración con Vite para un ciclo de desarrollo rápido y eficiente.  
- **Rendimiento:** Lazy loading y code splitting nativo de Vite.  
- **Testabilidad:** Componentes desacoplados listos para pruebas unitarias.  

---

> Esta arquitectura asegura independencia entre capas, alta mantenibilidad y escalabilidad, promoviendo pruebas unitarias y modularización por funcionalidades, acorde con las buenas prácticas del *Ecommerce de Ropa*.

[🏠 Home](../../README.md) | [Siguiente ➡️](../7.2/7.2.md)
